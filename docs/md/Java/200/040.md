# 前言

> 测试 Spring 如何识别 监听器Listener 的事件类型ApplicationEvent

# 识别监听器的事件类型 ApplicationEvent

伪代码测试，Spring 如何识别 监听器Listener 的事件类型ApplicationEvent

```java
package com.wjs.learn.test;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.AbstractApplicationEventMulticaster;
import org.springframework.context.event.ApplicationListenerMethodAdapter;
import org.springframework.context.event.GenericApplicationListenerAdapter;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.core.ResolvableType;
import org.springframework.transaction.event.TransactionalApplicationListenerMethodAdapter;
import org.springframework.transaction.event.TransactionalEventListener;
import org.springframework.util.ReflectionUtils;
import java.lang.reflect.Method;

/**
 * 测试 Spring 如何识别 监听器Listener 的事件类型ApplicationEvent
 *
 * @author admin
 * @see TransactionalApplicationListenerMethodAdapter#onApplicationEvent(ApplicationEvent)
 * @see ApplicationListenerMethodAdapter#ApplicationListenerMethodAdapter(String, Class, Method)
 * @see ResolvableType#forMethodParameter(Method, int)
 *
 * @see GenericApplicationListenerAdapter#resolveDeclaredEventType(Class)
 * @see GenericApplicationListenerAdapter#resolveDeclaredEventType(ApplicationListener)
 * @see GenericApplicationListenerAdapter#GenericApplicationListenerAdapter(ApplicationListener)
 * @see AbstractApplicationEventMulticaster#supportsEvent(ApplicationListener, ResolvableType, Class)
 * @see AbstractApplicationEventMulticaster#retrieveApplicationListeners(ResolvableType, Class, AbstractApplicationEventMulticaster.CachedListenerRetriever)
 * @see AbstractApplicationEventMulticaster#getApplicationListeners(ApplicationEvent, ResolvableType)
 * @see AbstractApplicationContext#publishEvent(Object, ResolvableType)
 */
public class ResolvableTypeTest {
    public static void main(String[] args) {
        Method[] methods = ReflectionUtils.getAllDeclaredMethods(TransactionalApplicationListener.class);
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        // 识别事件 TransactionalApplicationEvent 的类型
        Method method = ReflectionUtils.findMethod(TransactionalApplicationListener.class, "onApplicationEvent", TransactionalApplicationEvent.class);
        ResolvableType resolvableType = ResolvableType.forMethodParameter(method, 0);
        System.out.println("识别事件 TransactionalApplicationEvent 的类型 = " + resolvableType);

        // 识别事件类型 TransactionalApplicationEvent 方式二：通过类解析泛型
        ResolvableType ConnectionApplicationListenerResolvableType = ResolvableType.forClass(ConnectionApplicationListener.class);
        for (ResolvableType generic : ConnectionApplicationListenerResolvableType.getGenerics()) {
            System.out.println("识别事件类型 = " + generic.getType().getTypeName());
        }
    }

    /**
     * 定义 Spring 事务提交的监听器
     *
     * @author admin
     */
    static class TransactionalApplicationListener {

        @TransactionalEventListener
        public void onApplicationEvent(TransactionalApplicationEvent event) {
            System.out.println("TransactionalApplicationListener.onApplicationEvent");
        }
    }

    /**
     * 定义 Spring 事务提交通知的事件对象
     *
     * @author admin
     */
    static class TransactionalApplicationEvent extends ApplicationEvent {

        public TransactionalApplicationEvent(Object source) {
            super(source);
        }
    }

    /**
     * 连接监听器
     *
     * @param <ConnectionApplicationEvent>
     */
    static class ConnectionApplicationListener<ConnectionApplicationEvent> {

    }

    /**
     * 连接事件
     */
    static class ConnectionApplicationEvent extends ApplicationEvent {

        public ConnectionApplicationEvent(Object source) {
            super(source);
        }
    }
}
```

---

控制台打印

```text
onApplicationEvent
识别事件 TransactionalApplicationEvent 的类型 = com.wjs.learn.test.ResolvableTypeTest$TransactionalApplicationEvent
识别事件类型 = ConnectionApplicationEvent
```

# 参考 Spring 源码

监听器通知源码：TransactionalApplicationListenerMethodAdapter#onApplicationEvent

```java 
public class TransactionalApplicationListenerMethodAdapter extends ApplicationListenerMethodAdapter implements TransactionalApplicationListener<ApplicationEvent> {
	private final List<ResolvableType> declaredEventTypes;
	
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		processEvent(event);
	}
	
	public void processEvent(ApplicationEvent event) {
		Object[] args = resolveArguments(event);
	}
	
	@Nullable
	protected Object[] resolveArguments(ApplicationEvent event) {
		ResolvableType declaredEventType = getResolvableType(event);
	}
	
	@Nullable
	private ResolvableType getResolvableType(ApplicationEvent event) {
		for (ResolvableType declaredEventType : this.declaredEventTypes) {
			Class<?> eventClass = declaredEventType.toClass();
			if (!ApplicationEvent.class.isAssignableFrom(eventClass) &&
					payloadType != null && declaredEventType.isAssignableFrom(payloadType)) {
				return declaredEventType;
			}
			if (eventClass.isInstance(event)) {
				return declaredEventType;
			}
		}
		return null;
	}
}
```

--- 

对象初始化解析事件类型，源码：ApplicationListenerMethodAdapter#ApplicationListenerMethodAdapter

```java 
public class ApplicationListenerMethodAdapter implements GenericApplicationListener {
    public ApplicationListenerMethodAdapter(String beanName, Class<?> targetClass, Method method) {
        this.beanName = beanName;
        this.method = BridgeMethodResolver.findBridgedMethod(method);
        this.targetMethod = (!Proxy.isProxyClass(targetClass) ?
                AopUtils.getMostSpecificMethod(method, targetClass) : this.method);
        this.methodKey = new AnnotatedElementKey(this.targetMethod, targetClass);
    
        EventListener ann = AnnotatedElementUtils.findMergedAnnotation(this.targetMethod, EventListener.class);
        
        // 解析监听器方法的事件对象类型
        this.declaredEventTypes = resolveDeclaredEventTypes(method, ann);
        this.condition = (ann != null ? ann.condition() : null);
        this.order = resolveOrder(this.targetMethod);
        String id = (ann != null ? ann.id() : "");
        this.listenerId = (!id.isEmpty() ? id : null);
    }
    
    private static List<ResolvableType> resolveDeclaredEventTypes(Method method, @Nullable EventListener ann) {
		int count = method.getParameterCount();
		if (count > 1) {
			throw new IllegalStateException(
					"Maximum one parameter is allowed for event listener method: " + method);
		}

		if (ann != null) {
			Class<?>[] classes = ann.classes();
			if (classes.length > 0) {
				List<ResolvableType> types = new ArrayList<>(classes.length);
				for (Class<?> eventType : classes) {
					types.add(ResolvableType.forClass(eventType));
				}
				return types;
			}
		}

		if (count == 0) {
			throw new IllegalStateException(
					"Event parameter is mandatory for event listener method: " + method);
		}
		
		// 解析监听器方法的事件对象类型 ResolvableType.forMethodParameter
		return Collections.singletonList(ResolvableType.forMethodParameter(method, 0));
	}
}
```

---

查找监听器，源码：org.springframework.context.event.AbstractApplicationEventMulticaster#getApplicationListeners(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)

```java 
protected Collection<ApplicationListener<?>> getApplicationListeners(ApplicationEvent event, ResolvableType eventType) {
    return retrieveApplicationListeners(eventType, sourceType, newRetriever);
}

private Collection<ApplicationListener<?>> retrieveApplicationListeners(ResolvableType eventType, @Nullable Class<?> sourceType, @Nullable CachedListenerRetriever retriever) {
    if (!listenerBeans.isEmpty()) {
        ConfigurableBeanFactory beanFactory = getBeanFactory();
        for (String listenerBeanName : listenerBeans) {
            try {
                if (supportsEvent(beanFactory, listenerBeanName, eventType)) {
                    ApplicationListener<?> listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class);
                       
                    // supportsEvent(listener, eventType, sourceType) ，事件类型匹配监听器
                    if (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {
                        if (retriever != null) {
                            if (beanFactory.isSingleton(listenerBeanName)) {
                                filteredListeners.add(listener);
                            }
                            else {
                                filteredListenerBeans.add(listenerBeanName);
                            }
                        }
                        allListeners.add(listener);
                    }
                }
            }
            catch (NoSuchBeanDefinitionException ex) {
            }
        }
    }
    
    return allListeners;
}
```
---

事件类型匹配监听器，源码：org.springframework.context.event.AbstractApplicationEventMulticaster#supportsEvent(org.springframework.context.ApplicationListener<?>, org.springframework.core.ResolvableType, java.lang.Class<?>)

```java 
protected boolean supportsEvent(ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {
    
    // 将 ApplicationListener 监听器进一步包装为适配器 GenericApplicationListenerAdapter，GenericApplicationListenerAdapter 解析监听器事件类型
    GenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ? (GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener));
    return (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));
}
```

---

解析监听器的事件类型，将监听器和事件类型包装在适配器里，源码：org.springframework.context.event.GenericApplicationListenerAdapter#GenericApplicationListenerAdapter

```java 
public class GenericApplicationListenerAdapter implements GenericApplicationListener {
	private static final Map<Class<?>, ResolvableType> eventTypeCache = new ConcurrentReferenceHashMap<>();
	
	private final ApplicationListener<ApplicationEvent> delegate;

	@Nullable
	private final ResolvableType declaredEventType;
	
    public GenericApplicationListenerAdapter(ApplicationListener<?> delegate) {
        Assert.notNull(delegate, "Delegate listener must not be null");
        this.delegate = (ApplicationListener<ApplicationEvent>) delegate;
        // 解析 ApplicationListener 监听器的事件类型
        this.declaredEventType = resolveDeclaredEventType(this.delegate);
    }
}

private static ResolvableType resolveDeclaredEventType(ApplicationListener<ApplicationEvent> listener) {
    // 解析 ApplicationListener 监听器的事件类型
    ResolvableType declaredEventType = resolveDeclaredEventType(listener.getClass());
    if (declaredEventType == null || declaredEventType.isAssignableFrom(ApplicationEvent.class)) {
        Class<?> targetClass = AopUtils.getTargetClass(listener);
        if (targetClass != listener.getClass()) {
            declaredEventType = resolveDeclaredEventType(targetClass);
        }
    }
    return declaredEventType;
}

static ResolvableType resolveDeclaredEventType(Class<?> listenerType) {
    ResolvableType eventType = eventTypeCache.get(listenerType);
    if (eventType == null) {
        // 解析 ApplicationListener 监听器的事件类型
        eventType = ResolvableType.forClass(listenerType).as(ApplicationListener.class).getGeneric();
        eventTypeCache.put(listenerType, eventType);
    }
    return (eventType != ResolvableType.NONE ? eventType : null);
}
```

